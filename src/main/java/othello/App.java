/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package othello;

import java.util.*;
import java.util.function.Predicate;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import static othello.Square.Symbol.*;

public class App {

    public static void main(String[] args) {
        new App();
    }

    private final Board board = new Board(8, 8);
    private final Map<Square, List<Square>> legalMoves = new HashMap<>();
    private boolean turn = true;

    public App() {
        prepareBoard();
        while (true) {
            if (isGameOver()) {
                printBoard();
                System.out.printf("%s%n%s%n", getResult(), "The winner is... " + getWinner());
                break;
            }
            updateLegalMoves();
            if (!anyLegalMoves()) {
                System.out.printf("%s%n", "No legal moves available for " + getCurrentSymbol());
                nextTurn();
                continue;
            }
            showLegalMoves();
            printBoard();

            Square square = getUserInput();

            if (!isLegalMove(square))
                continue;
            hideLegalMoves();
            makeMove(square);
            clearLegalMoves();
            nextTurn();
        }
    }

    public String getResult() {
        this.board.countSquares();
        return String.format(
                "%s %s %s %s %s", PLAYER_ONE, PLAYER_ONE.getResult(), getSign(), PLAYER_TWO.getResult(), PLAYER_TWO
        );
    }

    public Square.Symbol getCurrentSymbol() {
        return (this.turn) ? PLAYER_ONE : PLAYER_TWO;
    }

    public void nextTurn() {
        this.turn = !this.turn;
    }

    public void prepareBoard() {
        this.board.setSquare(3, 3, PLAYER_ONE);
        this.board.setSquare(3, 4, PLAYER_TWO);
        this.board.setSquare(4, 3, PLAYER_TWO);
        this.board.setSquare(4, 4, PLAYER_ONE);
    }

    public void printBoard() {
        System.out.println(this.board);
    }

    public int[] input(String text) {
        int[] result = new int[2];
        while (true) {
            try {
                Scanner scanner = new Scanner(System.in);
                System.out.printf("%s", text);
                result[0] = scanner.nextInt();
                result[1] = scanner.nextInt();
                if (result[0] < 0 || result[0] >= this.board.getNumberOfRows() || result[1] < 0 || result[1] >= this.board.getNumberOfColumns())
                    throw new IndexOutOfBoundsException();
                break;
            } catch (InputMismatchException | IndexOutOfBoundsException e) {
                System.out.printf("%s%n", e.getMessage());
            } catch (NoSuchElementException e) {
                System.out.printf("%s%n", "Bye...");
                System.exit(0);
            }
        }
        return result;
    }

    public Square getUserInput() {
        System.out.printf("%s%n%s%n%s%n", getResult(), getCurrentSymbol() + "\'s turn...", "----------------------------------------");
        int[] x = input("ROW COL -> ");
        int row = x[0], col = x[1];
        Square square = this.board.getSquare(row, col);
        return square;
    }

    public boolean isLegalMove(Square square) {
        return this.legalMoves.containsKey(square);
    }

    public boolean anyLegalMoves() {
        return !this.legalMoves.isEmpty();
    }

    public void updateLegalMoves() {
        this.board.stream().filter(Square::isEmpty).forEach(square -> {
            List<Square> flankedSquares = getFlankedSquares(square);
            if (!flankedSquares.isEmpty()) this.legalMoves.put(square, flankedSquares);
        });
    }

    public void showLegalMoves() {
        // add '?' for legal moves
        this.board.stream().filter(this.legalMoves::containsKey).forEach(square -> square.setSymbol(LEGAL));
    }

    public void hideLegalMoves() {
        // remove '?' for legal moves
        this.board.stream().filter(square -> square.getSymbol() == LEGAL).forEach(square -> square.setSymbol(EMPTY));
    }

    public void clearLegalMoves() {
        this.legalMoves.clear();
    }

    private List<Square> getFlankedSquares(final Square square) {
        int row = square.getRow();
        int col = square.getColumn();

        return Stream.of(getHorizontalLine(row), getVerticalLine(col), getDiagonalLineA(row, col), getDiagonalLineB(row, col))
                .map(line -> getFlankedSquaresAlongLine(square, line))
                .flatMap(Collection::stream)
                .collect(Collectors.toList());
    }

    private String convertLineToString(Square square, List<Square> line) {
        return line.stream().map(square1 -> {
            if (square1 == square) return "S";
            else if (square1.isSame(getCurrentSymbol())) return "s";
            else if (square1.isOpposite(getCurrentSymbol())) return "0";
            else return "1";
        }).reduce("", String::concat);
    }

    public List<Square> getFlankedSquaresAlongLine(Square square, List<Square> line) {
        String stringifiedLine = convertLineToString(square, line);
        String[] backwardForward = stringifiedLine.split("S", -1);
        String backward = backwardForward[0], forward = backwardForward[1];
        String[] arrBackward = backward.split("s", -1), arrForward = forward.split("s", -1);
        int SPos = stringifiedLine.indexOf("S"), sBackwardPos = stringifiedLine.lastIndexOf("s", SPos), sForwardPos = stringifiedLine.indexOf("s", SPos);

        List<Square> flankedSquares = new ArrayList<>();
        if (arrBackward[arrBackward.length - 1].matches("0+") && sBackwardPos != -1)
            flankedSquares.addAll(line.subList(sBackwardPos, SPos));
        if (arrForward[0].matches("0+") && sForwardPos != -1)
            flankedSquares.addAll(line.subList(SPos + 1, sForwardPos + 1));
        return flankedSquares;
    }

    private List<Square> getLine(Predicate<Square> predicate) {
        return this.board.stream().filter(predicate).collect(Collectors.toList());
    }

    public List<Square> getHorizontalLine(final int row) {
        return getLine(square -> square.getRow() == row);
    }

    public List<Square> getVerticalLine(final int col) {
        return getLine(square -> square.getColumn() == col);
    }

    public List<Square> getDiagonalLineA(final int row, final int col) {
        return getLine(square -> square.getRow() == - square.getColumn() + row + col);
    }

    public List<Square> getDiagonalLineB(final int row, final int col) {
        return getLine(square -> square.getRow() == square.getColumn() + row - col);
    }

    public void makeMove(final Square square) {
        Stream.concat(Stream.of(square), this.legalMoves.get(square).stream()).forEach(square1 -> square1.setSymbol(getCurrentSymbol()));
    }

    public boolean isGameOver() {
        return !this.board.hasEmptySquares();
    }
}
